#!/usr/bin/env python
"""
Utility to launch a python script on SLURM, using CPU or GPU. Uses configuration
information from config.json and supports launching multiple repeats.

Flags can be passed to the delegated script by appending them at the end as follows
    > launcher RESOURCE {--runs} SCRIPT FLAGS
e.g.
    > launcher moran-gpu --runs=2 dummy_gpujob.py --epochs=10 --seed 42
is equivalent to twice running this:
    > python dummy_gpujob.py --epochs=10 --seed 42

Furthermore, any settings accepted by `sbatch` may be supplied on the command line.
These will override the options provided by config.json, if given. For example, to
add more memory to an existing config:
    > launcher dggpu --mem=64G dummy_gpujob.py --epochs=10 --seed 42

IMPORTANT: The sbatch options must be supplied in "--name=value" fashion, with an
equals sign; "--name value" will NOT parse correctly. For any other options
(including script flags) you may use either format.
"""

import argparse
import tempfile
import json
import os
import subprocess as sub
from datetime import date
from pathlib import Path
from uuid import uuid4

from tqdm import tqdm

DEBUG = os.getenv("DEBUG", None) is not None


class HelpFormatter(argparse.RawDescriptionHelpFormatter, argparse.ArgumentDefaultsHelpFormatter):
    """
    This class adds no new functionality, only is used to combine the existing functionality of two different
    formatters through multiple inheritance.
    """
    pass


def slurm_launcher(cmd, sbatch_args):
    """
    Create a temp file with the slurm sbatch syntax, launch it and then delete it
    """
    if DEBUG:
        print("\n#### OUTPUT SCRIPT ####")
        print(cmd)
        print("\n#### SBATCH CALL ####")
        sbatch_cmd = ["sbatch"] + sbatch_args + ["<file>"]
        print(" ".join(sbatch_cmd))
        print()
        return

    with tempfile.NamedTemporaryFile() as f:
        f.write(cmd.encode("utf-8"))
        f.flush()
        sub.call(["sbatch"] + sbatch_args + [f"{f.name}"], shell=False)


def make_slurm_script(conf, cmd):
    """
    Generate the information to be passed to SLURM about the job
    Also take care of setting up the environment
    The python command will be added afterwards
    """
    # The shebang is not needed by slurm, but can be useful if we want to try running the script
    # ourselves.
    shebang = "#!/bin/bash"
    flags = "\n".join(
        f"#SBATCH --{flag}={value}" for flag, value in conf["resources"].items()
    )
    script = f"{shebang}\n{flags}\n\n"
    script += "source ~/.bash_profile\n"  # build the user's environment just as if we spawned a new login shell
    script += "cd ${SLURM_SUBMIT_DIR}\n"  # run in the same directory as the python script, so relative paths work
    script += f"echo 'Command: {cmd}'\n"  # print the command we're about to run
    script += f"{conf['env']} && {cmd}"  # activate conda env and launch script if successful
    return script


if __name__ == "__main__":

    if DEBUG:
        print(
            "#####################\n" + "##### DEBUG MODE ####\n"
            "#####################\n"
        )

    parser = argparse.ArgumentParser(description=__doc__, formatter_class=HelpFormatter)
    parser.add_argument(
        "resource",
        help="Identifier of the resource configuration to use. Must be one of the configs present in config.json.",
    )
    parser.add_argument(
        "--runs",
        type=int,
        help="How many repetitions to run.",
        default=1,
    )
    parser.add_argument(
        "-d",
        "--rundir",
        help="The directory from which to launch the script. Slurm output will be directed here.",
    )
    parser.add_argument(
        "-f",
        "--force",
        action="store_true",
        help="Launch a new job even if another job has already used this output directory. Does not remove the"
        " previous output log, and only needed when specifying --rundir.",
    )
    parser.add_argument("entry", help="The python script to launch.")
    parser.add_argument("flags", nargs=argparse.REMAINDER, help="Flags to be passed to the python script.")
    args, sbatch_args = parser.parse_known_args()

    ################# VALIDATE INPUT #################
    # Find config file in the same folder as this launcher script.
    config_file = Path(__file__).parent / "config.json"
    print(args)

    if args.rundir:
        rundir = Path(args.rundir)
        if not DEBUG:
            rundir.mkdir(exist_ok=True, parents=True)
        if not args.force and list(rundir.glob("slurm-*.out")):
            parser.error(f"A Slurm output file already exists in the target directory: {rundir.resolve()}.\nUse"
                         " -f/--force to run in this folder anyway.")
    else:
        rundir = Path(".")

    entry_path = Path(args.entry).resolve()
    assert entry_path.exists(), f"File {entry_path} not found."
    assert entry_path.is_file(), f"File {entry_path} is not a file."
    assert config_file.exists(), f"Configuration file ({config_file}) not found."
    assert config_file.is_file(), f"Configuration file ({config_file}) is not a file."
    with open(config_file, "r") as f:
        available_configs = json.loads(f.read())
    assert (
        args.resource in available_configs.keys()
    ), f"Requested configuration ({args.resource}) not found in config file ({config_file})"

    config = available_configs[args.resource]
    device = config["device"]
    assert device in [
        "cpu",
        "gpu",
    ], f"Wrong device requested: {device} not in [cpu, gpu]"
    ##################################################

    if not DEBUG:
        os.chdir(rundir)
    print("Running from:", rundir.resolve())
    print("File:", entry_path)
    print("Flags:", args.flags)
    print("Config:\n", json.dumps(config, indent=2, sort_keys=True))

    cmd = f"time python {entry_path} {' '.join(args.flags)}"
    scripts = [make_slurm_script(config, cmd) for _ in range(args.runs)]

    for i, script in enumerate(scripts):
        slurm_launcher(script, sbatch_args)
